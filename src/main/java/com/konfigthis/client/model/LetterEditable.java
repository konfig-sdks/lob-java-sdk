/*
 * Lob
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> 
 *
 * The version of the OpenAPI document: 1.19.28
 * Contact: lob-openapi@lob.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.AddressPlacement;
import com.konfigthis.client.model.ExtraService;
import com.konfigthis.client.model.LtrSize;
import com.konfigthis.client.model.LtrUseType;
import com.konfigthis.client.model.MailType;
import com.konfigthis.client.model.QrCode;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * LetterEditable
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class LetterEditable {
  public static final String SERIALIZED_NAME_TO = "to";
  @SerializedName(SERIALIZED_NAME_TO)
  private Object to = null;

  public static final String SERIALIZED_NAME_FROM = "from";
  @SerializedName(SERIALIZED_NAME_FROM)
  private Object from = null;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = null;

  public static final String SERIALIZED_NAME_MAIL_TYPE = "mail_type";
  @SerializedName(SERIALIZED_NAME_MAIL_TYPE)
  private MailType mailType = MailType.FIRST_CLASS;

  public static final String SERIALIZED_NAME_MERGE_VARIABLES = "merge_variables";
  @SerializedName(SERIALIZED_NAME_MERGE_VARIABLES)
  private String mergeVariables;

  public static final String SERIALIZED_NAME_SEND_DATE = "send_date";
  @SerializedName(SERIALIZED_NAME_SEND_DATE)
  private Object sendDate = null;

  public static final String SERIALIZED_NAME_FILE = "file";
  @SerializedName(SERIALIZED_NAME_FILE)
  private Object _file = null;

  public static final String SERIALIZED_NAME_EXTRA_SERVICE = "extra_service";
  @SerializedName(SERIALIZED_NAME_EXTRA_SERVICE)
  private ExtraService extraService;

  public static final String SERIALIZED_NAME_CARDS = "cards";
  @SerializedName(SERIALIZED_NAME_CARDS)
  private List<String> cards = null;

  public static final String SERIALIZED_NAME_COLOR = "color";
  @SerializedName(SERIALIZED_NAME_COLOR)
  private Boolean color;

  public static final String SERIALIZED_NAME_DOUBLE_SIDED = "double_sided";
  @SerializedName(SERIALIZED_NAME_DOUBLE_SIDED)
  private Boolean doubleSided = true;

  public static final String SERIALIZED_NAME_ADDRESS_PLACEMENT = "address_placement";
  @SerializedName(SERIALIZED_NAME_ADDRESS_PLACEMENT)
  private AddressPlacement addressPlacement = AddressPlacement.TOP_FIRST_PAGE;

  public static final String SERIALIZED_NAME_RETURN_ENVELOPE = "return_envelope";
  @SerializedName(SERIALIZED_NAME_RETURN_ENVELOPE)
  private Object returnEnvelope = null;

  public static final String SERIALIZED_NAME_PERFORATED_PAGE = "perforated_page";
  @SerializedName(SERIALIZED_NAME_PERFORATED_PAGE)
  private Integer perforatedPage;

  public static final String SERIALIZED_NAME_CUSTOM_ENVELOPE = "custom_envelope";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ENVELOPE)
  private String customEnvelope;

  public static final String SERIALIZED_NAME_BILLING_GROUP_ID = "billing_group_id";
  @SerializedName(SERIALIZED_NAME_BILLING_GROUP_ID)
  private String billingGroupId;

  public static final String SERIALIZED_NAME_QR_CODE = "qr_code";
  @SerializedName(SERIALIZED_NAME_QR_CODE)
  private QrCode qrCode;

  public static final String SERIALIZED_NAME_USE_TYPE = "use_type";
  @SerializedName(SERIALIZED_NAME_USE_TYPE)
  private LtrUseType useType;

  public static final String SERIALIZED_NAME_FSC = "fsc";
  @SerializedName(SERIALIZED_NAME_FSC)
  private Boolean fsc = false;

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private LtrSize size = LtrSize.LETTER;

  public LetterEditable() {
  }

  public LetterEditable to(Object to) {
    
    
    
    
    this.to = to;
    return this;
  }

   /**
   * Get to
   * @return to
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Object getTo() {
    return to;
  }


  public void setTo(Object to) {
    
    
    
    this.to = to;
  }


  public LetterEditable from(Object from) {
    
    
    
    
    this.from = from;
    return this;
  }

   /**
   * Get from
   * @return from
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Object getFrom() {
    return from;
  }


  public void setFrom(Object from) {
    
    
    
    this.from = from;
  }


  public LetterEditable description(String description) {
    
    
    
    
    this.description = description;
    return this;
  }

   /**
   * An internal description that identifies this resource. Must be no longer than 255 characters. 
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Harry - Office", value = "An internal description that identifies this resource. Must be no longer than 255 characters. ")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    
    
    
    this.description = description;
  }


  public LetterEditable metadata(Map<String, String> metadata) {
    
    
    
    
    this.metadata = metadata;
    return this;
  }

  public LetterEditable putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

   /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters &#x60;\&quot;&#x60; and &#x60;\\&#x60;. i.e. &#39;{\&quot;customer_id\&quot; : \&quot;NEWYORK2015\&quot;}&#39; Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. '{\"customer_id\" : \"NEWYORK2015\"}' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.")

  public Map<String, String> getMetadata() {
    return metadata;
  }


  public void setMetadata(Map<String, String> metadata) {
    
    
    
    this.metadata = metadata;
  }


  public LetterEditable mailType(MailType mailType) {
    
    
    
    
    this.mailType = mailType;
    return this;
  }

   /**
   * Get mailType
   * @return mailType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public MailType getMailType() {
    return mailType;
  }


  public void setMailType(MailType mailType) {
    
    
    
    this.mailType = mailType;
  }


  public LetterEditable mergeVariables(String mergeVariables) {
    
    
    
    
    this.mergeVariables = mergeVariables;
    return this;
  }

   /**
   * You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: &#x60;{{variable_name}}&#x60;, pass in &#x60;{\&quot;variable_name\&quot;: \&quot;Harry\&quot;}&#x60; to render &#x60;Harry&#x60;. &#x60;merge_variables&#x60; must be an object. Any type of value is accepted as long as the object is valid JSON; you can use &#x60;strings&#x60;, &#x60;numbers&#x60;, &#x60;booleans&#x60;, &#x60;arrays&#x60;, &#x60;objects&#x60;, or &#x60;null&#x60;. The max length of the object is 25,000 characters. If you call &#x60;JSON.stringify&#x60; on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: &#x60;!&#x60;, &#x60;\&quot;&#x60;, &#x60;#&#x60;, &#x60;%&#x60;, &#x60;&amp;&#x60;, &#x60;&#39;&#x60;, &#x60;(&#x60;, &#x60;)&#x60;, &#x60;*&#x60;, &#x60;+&#x60;, &#x60;,&#x60;, &#x60;/&#x60;, &#x60;;&#x60;, &#x60;&lt;&#x60;, &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;@&#x60;, &#x60;[&#x60;, &#x60;\\&#x60;, &#x60;]&#x60;, &#x60;^&#x60;, &#x60;&#x60; &#x60; &#x60;&#x60;, &#x60;{&#x60;, &#x60;|&#x60;, &#x60;}&#x60;, &#x60;~&#x60;. More instructions can be found in &lt;a href&#x3D;\&quot;https://help.lob.com/print-and-mail/designing-mail-creatives/dynamic-personalization#using-html-and-merge-variables-10\&quot; target&#x3D;\&quot;_blank\&quot;&gt;our guide to using html and merge variables&lt;/a&gt;. Depending on your &lt;a href&#x3D;\&quot;https://dashboard.lob.com/#/settings/account\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Merge Variable strictness&lt;/a&gt; setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.
   * @return mergeVariables
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: `{{variable_name}}`, pass in `{\"variable_name\": \"Harry\"}` to render `Harry`. `merge_variables` must be an object. Any type of value is accepted as long as the object is valid JSON; you can use `strings`, `numbers`, `booleans`, `arrays`, `objects`, or `null`. The max length of the object is 25,000 characters. If you call `JSON.stringify` on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: `!`, `\"`, `#`, `%`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `/`, `;`, `<`, `=`, `>`, `@`, `[`, `\\`, `]`, `^`, `` ` ``, `{`, `|`, `}`, `~`. More instructions can be found in <a href=\"https://help.lob.com/print-and-mail/designing-mail-creatives/dynamic-personalization#using-html-and-merge-variables-10\" target=\"_blank\">our guide to using html and merge variables</a>. Depending on your <a href=\"https://dashboard.lob.com/#/settings/account\" target=\"_blank\">Merge Variable strictness</a> setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.")

  public String getMergeVariables() {
    return mergeVariables;
  }


  public void setMergeVariables(String mergeVariables) {
    
    
    
    this.mergeVariables = mergeVariables;
  }


  public LetterEditable sendDate(Object sendDate) {
    
    
    
    
    this.sendDate = sendDate;
    return this;
  }

   /**
   * Get sendDate
   * @return sendDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Object getSendDate() {
    return sendDate;
  }


  public void setSendDate(Object sendDate) {
    
    
    
    this.sendDate = sendDate;
  }


  public LetterEditable _file(Object _file) {
    
    
    
    
    this._file = _file;
    return this;
  }

   /**
   * Get _file
   * @return _file
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Object getFile() {
    return _file;
  }


  public void setFile(Object _file) {
    
    
    
    this._file = _file;
  }


  public LetterEditable extraService(ExtraService extraService) {
    
    
    
    
    this.extraService = extraService;
    return this;
  }

   /**
   * Get extraService
   * @return extraService
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ExtraService getExtraService() {
    return extraService;
  }


  public void setExtraService(ExtraService extraService) {
    
    
    
    this.extraService = extraService;
  }


  public LetterEditable cards(List<String> cards) {
    
    
    
    
    this.cards = cards;
    return this;
  }

  public LetterEditable addCardsItem(String cardsItem) {
    if (this.cards == null) {
      this.cards = new ArrayList<>();
    }
    this.cards.add(cardsItem);
    return this;
  }

   /**
   * A single-element array containing an existing card id in a string format. See [cards](#tag/Cards) for more information. Not available for &#x60;us_legal&#x60; letter size.
   * @return cards
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A single-element array containing an existing card id in a string format. See [cards](#tag/Cards) for more information. Not available for `us_legal` letter size.")

  public List<String> getCards() {
    return cards;
  }


  public void setCards(List<String> cards) {
    
    
    
    this.cards = cards;
  }


  public LetterEditable color(Boolean color) {
    
    
    
    
    this.color = color;
    return this;
  }

   /**
   * Get color
   * @return color
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Boolean getColor() {
    return color;
  }


  public void setColor(Boolean color) {
    
    
    
    this.color = color;
  }


  public LetterEditable doubleSided(Boolean doubleSided) {
    
    
    
    
    this.doubleSided = doubleSided;
    return this;
  }

   /**
   * Set this attribute to &#x60;true&#x60; for double sided printing, or &#x60;false&#x60; for for single sided printing. Defaults to &#x60;true&#x60;.
   * @return doubleSided
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "true", value = "Set this attribute to `true` for double sided printing, or `false` for for single sided printing. Defaults to `true`.")

  public Boolean getDoubleSided() {
    return doubleSided;
  }


  public void setDoubleSided(Boolean doubleSided) {
    
    
    
    this.doubleSided = doubleSided;
  }


  public LetterEditable addressPlacement(AddressPlacement addressPlacement) {
    
    
    
    
    this.addressPlacement = addressPlacement;
    return this;
  }

   /**
   * Get addressPlacement
   * @return addressPlacement
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public AddressPlacement getAddressPlacement() {
    return addressPlacement;
  }


  public void setAddressPlacement(AddressPlacement addressPlacement) {
    
    
    
    this.addressPlacement = addressPlacement;
  }


  public LetterEditable returnEnvelope(Object returnEnvelope) {
    
    
    
    
    this.returnEnvelope = returnEnvelope;
    return this;
  }

   /**
   * Get returnEnvelope
   * @return returnEnvelope
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Object getReturnEnvelope() {
    return returnEnvelope;
  }


  public void setReturnEnvelope(Object returnEnvelope) {
    
    
    
    this.returnEnvelope = returnEnvelope;
  }


  public LetterEditable perforatedPage(Integer perforatedPage) {
    
    
    
    
    this.perforatedPage = perforatedPage;
    return this;
  }

   /**
   * Required if &#x60;return_envelope&#x60; is &#x60;true&#x60;. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to &#x60;1&#x60;. The blank page added by &#x60;address_placement&#x3D;insert_blank_page&#x60; will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our &lt;a href&#x3D;\&quot;https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf\&quot; target&#x3D;\&quot;_blank\&quot;&gt;perforation guide&lt;/a&gt;.
   * @return perforatedPage
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Required if `return_envelope` is `true`. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to `1`. The blank page added by `address_placement=insert_blank_page` will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our <a href=\"https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf\" target=\"_blank\">perforation guide</a>.")

  public Integer getPerforatedPage() {
    return perforatedPage;
  }


  public void setPerforatedPage(Integer perforatedPage) {
    
    
    
    this.perforatedPage = perforatedPage;
  }


  public LetterEditable customEnvelope(String customEnvelope) {
    
    
    
    
    this.customEnvelope = customEnvelope;
    return this;
  }

   /**
   * Accepts an envelope ID for any customized envelope with available inventory. If no inventory is available for the specified ID, the letter will not be sent, and an error will be returned. If the letter has more than 6 sheets, it will be sent in a blank flat envelope. Custom envelopes may be created and ordered from the dashboard. This feature is exclusive to certain customers. Upgrade to the appropriate &lt;a href&#x3D;\&quot;https://dashboard.lob.com/#/settings/editions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Print &amp; Mail Edition&lt;/a&gt; to gain access.
   * @return customEnvelope
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Accepts an envelope ID for any customized envelope with available inventory. If no inventory is available for the specified ID, the letter will not be sent, and an error will be returned. If the letter has more than 6 sheets, it will be sent in a blank flat envelope. Custom envelopes may be created and ordered from the dashboard. This feature is exclusive to certain customers. Upgrade to the appropriate <a href=\"https://dashboard.lob.com/#/settings/editions\" target=\"_blank\">Print & Mail Edition</a> to gain access.")

  public String getCustomEnvelope() {
    return customEnvelope;
  }


  public void setCustomEnvelope(String customEnvelope) {
    
    
    
    this.customEnvelope = customEnvelope;
  }


  public LetterEditable billingGroupId(String billingGroupId) {
    
    
    
    
    this.billingGroupId = billingGroupId;
    return this;
  }

   /**
   * An optional string with the billing group ID to tag your usage with. Is used for billing purposes. Requires special activation to use. See &lt;a href&#x3D;\&quot;#tag/Billing-Groups\&quot;&gt;Billing Group API&lt;/a&gt; for more information.
   * @return billingGroupId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An optional string with the billing group ID to tag your usage with. Is used for billing purposes. Requires special activation to use. See <a href=\"#tag/Billing-Groups\">Billing Group API</a> for more information.")

  public String getBillingGroupId() {
    return billingGroupId;
  }


  public void setBillingGroupId(String billingGroupId) {
    
    
    
    this.billingGroupId = billingGroupId;
  }


  public LetterEditable qrCode(QrCode qrCode) {
    
    
    
    
    this.qrCode = qrCode;
    return this;
  }

   /**
   * Get qrCode
   * @return qrCode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public QrCode getQrCode() {
    return qrCode;
  }


  public void setQrCode(QrCode qrCode) {
    
    
    
    this.qrCode = qrCode;
  }


  public LetterEditable useType(LtrUseType useType) {
    
    
    
    
    this.useType = useType;
    return this;
  }

   /**
   * Get useType
   * @return useType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public LtrUseType getUseType() {
    return useType;
  }


  public void setUseType(LtrUseType useType) {
    
    
    
    this.useType = useType;
  }


  public LetterEditable fsc(Boolean fsc) {
    
    
    
    
    this.fsc = fsc;
    return this;
  }

   /**
   * This is in beta. Contact support@lob.com or your account contact to learn more. Not available for &#x60;A4&#x60; and &#x60;us_legal&#x60; letter size.
   * @return fsc
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "This is in beta. Contact support@lob.com or your account contact to learn more. Not available for `A4` and `us_legal` letter size.")

  public Boolean getFsc() {
    return fsc;
  }


  public void setFsc(Boolean fsc) {
    
    
    
    this.fsc = fsc;
  }


  public LetterEditable size(LtrSize size) {
    
    
    
    
    this.size = size;
    return this;
  }

   /**
   * Get size
   * @return size
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public LtrSize getSize() {
    return size;
  }


  public void setSize(LtrSize size) {
    
    
    
    this.size = size;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the LetterEditable instance itself
   */
  public LetterEditable putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LetterEditable letterEditable = (LetterEditable) o;
    return Objects.equals(this.to, letterEditable.to) &&
        Objects.equals(this.from, letterEditable.from) &&
        Objects.equals(this.description, letterEditable.description) &&
        Objects.equals(this.metadata, letterEditable.metadata) &&
        Objects.equals(this.mailType, letterEditable.mailType) &&
        Objects.equals(this.mergeVariables, letterEditable.mergeVariables) &&
        Objects.equals(this.sendDate, letterEditable.sendDate) &&
        Objects.equals(this._file, letterEditable._file) &&
        Objects.equals(this.extraService, letterEditable.extraService) &&
        Objects.equals(this.cards, letterEditable.cards) &&
        Objects.equals(this.color, letterEditable.color) &&
        Objects.equals(this.doubleSided, letterEditable.doubleSided) &&
        Objects.equals(this.addressPlacement, letterEditable.addressPlacement) &&
        Objects.equals(this.returnEnvelope, letterEditable.returnEnvelope) &&
        Objects.equals(this.perforatedPage, letterEditable.perforatedPage) &&
        Objects.equals(this.customEnvelope, letterEditable.customEnvelope) &&
        Objects.equals(this.billingGroupId, letterEditable.billingGroupId) &&
        Objects.equals(this.qrCode, letterEditable.qrCode) &&
        Objects.equals(this.useType, letterEditable.useType) &&
        Objects.equals(this.fsc, letterEditable.fsc) &&
        Objects.equals(this.size, letterEditable.size)&&
        Objects.equals(this.additionalProperties, letterEditable.additionalProperties);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(to, from, description, metadata, mailType, mergeVariables, sendDate, _file, extraService, cards, color, doubleSided, addressPlacement, returnEnvelope, perforatedPage, customEnvelope, billingGroupId, qrCode, useType, fsc, size, additionalProperties);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LetterEditable {\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    mailType: ").append(toIndentedString(mailType)).append("\n");
    sb.append("    mergeVariables: ").append(toIndentedString(mergeVariables)).append("\n");
    sb.append("    sendDate: ").append(toIndentedString(sendDate)).append("\n");
    sb.append("    _file: ").append(toIndentedString(_file)).append("\n");
    sb.append("    extraService: ").append(toIndentedString(extraService)).append("\n");
    sb.append("    cards: ").append(toIndentedString(cards)).append("\n");
    sb.append("    color: ").append(toIndentedString(color)).append("\n");
    sb.append("    doubleSided: ").append(toIndentedString(doubleSided)).append("\n");
    sb.append("    addressPlacement: ").append(toIndentedString(addressPlacement)).append("\n");
    sb.append("    returnEnvelope: ").append(toIndentedString(returnEnvelope)).append("\n");
    sb.append("    perforatedPage: ").append(toIndentedString(perforatedPage)).append("\n");
    sb.append("    customEnvelope: ").append(toIndentedString(customEnvelope)).append("\n");
    sb.append("    billingGroupId: ").append(toIndentedString(billingGroupId)).append("\n");
    sb.append("    qrCode: ").append(toIndentedString(qrCode)).append("\n");
    sb.append("    useType: ").append(toIndentedString(useType)).append("\n");
    sb.append("    fsc: ").append(toIndentedString(fsc)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("to");
    openapiFields.add("from");
    openapiFields.add("description");
    openapiFields.add("metadata");
    openapiFields.add("mail_type");
    openapiFields.add("merge_variables");
    openapiFields.add("send_date");
    openapiFields.add("file");
    openapiFields.add("extra_service");
    openapiFields.add("cards");
    openapiFields.add("color");
    openapiFields.add("double_sided");
    openapiFields.add("address_placement");
    openapiFields.add("return_envelope");
    openapiFields.add("perforated_page");
    openapiFields.add("custom_envelope");
    openapiFields.add("billing_group_id");
    openapiFields.add("qr_code");
    openapiFields.add("use_type");
    openapiFields.add("fsc");
    openapiFields.add("size");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("to");
    openapiRequiredFields.add("from");
    openapiRequiredFields.add("file");
    openapiRequiredFields.add("color");
    openapiRequiredFields.add("use_type");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to LetterEditable
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!LetterEditable.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LetterEditable is not found in the empty JSON string", LetterEditable.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LetterEditable.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("description").isJsonNull() && (jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // ensure the optional json data is an array if present (nullable)
      if (jsonObj.get("cards") != null && !jsonObj.get("cards").isJsonNull() && !jsonObj.get("cards").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `cards` to be an array in the JSON string or null but got `%s`", jsonObj.get("cards").toString()));
      }
      // validate the required field `color`
      Boolean.validateJsonObject(jsonObj.getAsJsonObject("color"));
      if (!jsonObj.get("custom_envelope").isJsonNull() && (jsonObj.get("custom_envelope") != null && !jsonObj.get("custom_envelope").isJsonNull()) && !jsonObj.get("custom_envelope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `custom_envelope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("custom_envelope").toString()));
      }
      if ((jsonObj.get("billing_group_id") != null && !jsonObj.get("billing_group_id").isJsonNull()) && !jsonObj.get("billing_group_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `billing_group_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("billing_group_id").toString()));
      }
      // validate the optional field `qr_code`
      if (jsonObj.get("qr_code") != null && !jsonObj.get("qr_code").isJsonNull()) {
        QrCode.validateJsonObject(jsonObj.getAsJsonObject("qr_code"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LetterEditable.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LetterEditable' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LetterEditable> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LetterEditable.class));

       return (TypeAdapter<T>) new TypeAdapter<LetterEditable>() {
           @Override
           public void write(JsonWriter out, LetterEditable value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public LetterEditable read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             LetterEditable instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LetterEditable given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LetterEditable
  * @throws IOException if the JSON string is invalid with respect to LetterEditable
  */
  public static LetterEditable fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LetterEditable.class);
  }

 /**
  * Convert an instance of LetterEditable to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

