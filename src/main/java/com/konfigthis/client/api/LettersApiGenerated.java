/*
 * Lob
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> 
 *
 * The version of the OpenAPI document: 1.19.28
 * Contact: lob-openapi@lob.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AddressPlacement;
import com.konfigthis.client.model.AddressesListBeforeAfterParameterAllOf;
import com.konfigthis.client.model.ChecksListSortByParameterAllOf;
import com.konfigthis.client.model.Error;
import com.konfigthis.client.model.ExtraService;
import com.konfigthis.client.model.LetterDeletion;
import com.konfigthis.client.model.LetterEditable;
import com.konfigthis.client.model.LettersListResponse;
import com.konfigthis.client.model.LtrSize;
import com.konfigthis.client.model.LtrUseType;
import com.konfigthis.client.model.MailType;
import com.konfigthis.client.model.QrCode;
import com.konfigthis.client.model.Status;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class LettersApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public LettersApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public LettersApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call cancelCall(String ltrId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/letters/{ltr_id}"
            .replace("{" + "ltr_id" + "}", localVarApiClient.escapeString(ltrId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelValidateBeforeCall(String ltrId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ltrId' is set
        if (ltrId == null) {
            throw new ApiException("Missing the required parameter 'ltrId' when calling cancel(Async)");
        }

        return cancelCall(ltrId, _callback);

    }


    private ApiResponse<LetterDeletion> cancelWithHttpInfo(String ltrId) throws ApiException {
        okhttp3.Call localVarCall = cancelValidateBeforeCall(ltrId, null);
        Type localVarReturnType = new TypeToken<LetterDeletion>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call cancelAsync(String ltrId, final ApiCallback<LetterDeletion> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelValidateBeforeCall(ltrId, _callback);
        Type localVarReturnType = new TypeToken<LetterDeletion>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CancelRequestBuilder {
        private final String ltrId;

        private CancelRequestBuilder(String ltrId) {
            this.ltrId = ltrId;
        }

        /**
         * Build call for cancel
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Deleted </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return cancelCall(ltrId, _callback);
        }


        /**
         * Execute cancel request
         * @return LetterDeletion
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Deleted </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public LetterDeletion execute() throws ApiException {
            ApiResponse<LetterDeletion> localVarResp = cancelWithHttpInfo(ltrId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute cancel request with HTTP info returned
         * @return ApiResponse&lt;LetterDeletion&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Deleted </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LetterDeletion> executeWithHttpInfo() throws ApiException {
            return cancelWithHttpInfo(ltrId);
        }

        /**
         * Execute cancel request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Deleted </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LetterDeletion> _callback) throws ApiException {
            return cancelAsync(ltrId, _callback);
        }
    }

    /**
     * Cancel
     * Completely removes a letter from production. This can only be done if the letter has a &#x60;send_date&#x60; and the &#x60;send_date&#x60; has not yet passed. If the letter is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate &lt;a href&#x3D;\&quot;https://dashboard.lob.com/#/settings/editions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Print &amp; Mail Edition&lt;/a&gt; to gain access.
     * @param ltrId id of the letter (required)
     * @return CancelRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Deleted </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public CancelRequestBuilder cancel(String ltrId) throws IllegalArgumentException {
        if (ltrId == null) throw new IllegalArgumentException("\"ltrId\" is required but got null");
            

        return new CancelRequestBuilder(ltrId);
    }
    private okhttp3.Call createCall(LetterEditable letterEditable, String idempotencyKey, String idempotencyKey2, String lobVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = letterEditable;

        // create path and map variables
        String localVarPath = "/letters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idempotencyKey2 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idempotency_key", idempotencyKey2));
        }

        if (idempotencyKey != null) {
            localVarHeaderParams.put("Idempotency-Key", localVarApiClient.parameterToString(idempotencyKey));
        }

        if (lobVersion != null) {
            localVarHeaderParams.put("Lob-Version", localVarApiClient.parameterToString(lobVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createValidateBeforeCall(LetterEditable letterEditable, String idempotencyKey, String idempotencyKey2, String lobVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'letterEditable' is set
        if (letterEditable == null) {
            throw new ApiException("Missing the required parameter 'letterEditable' when calling create(Async)");
        }

        return createCall(letterEditable, idempotencyKey, idempotencyKey2, lobVersion, _callback);

    }


    private ApiResponse<Object> createWithHttpInfo(LetterEditable letterEditable, String idempotencyKey, String idempotencyKey2, String lobVersion) throws ApiException {
        okhttp3.Call localVarCall = createValidateBeforeCall(letterEditable, idempotencyKey, idempotencyKey2, lobVersion, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createAsync(LetterEditable letterEditable, String idempotencyKey, String idempotencyKey2, String lobVersion, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = createValidateBeforeCall(letterEditable, idempotencyKey, idempotencyKey2, lobVersion, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateRequestBuilder {
        private Object to;
        private Object from;
        private String description;
        private Map<String, String> metadata;
        private MailType mailType;
        private String mergeVariables;
        private Object sendDate;
        private Object _file;
        private ExtraService extraService;
        private List<String> cards;
        private Boolean color;
        private Boolean doubleSided;
        private AddressPlacement addressPlacement;
        private Object returnEnvelope;
        private Integer perforatedPage;
        private String customEnvelope;
        private String billingGroupId;
        private QrCode qrCode;
        private LtrUseType useType;
        private Boolean fsc;
        private LtrSize size;
        private String idempotencyKey;
        private String idempotencyKey2;
        private String lobVersion;

        private CreateRequestBuilder() {
        }

        /**
         * Set to
         * @param to  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder to(Object to) {
            this.to = to;
            return this;
        }
        
        /**
         * Set from
         * @param from  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder from(Object from) {
            this.from = from;
            return this;
        }
        
        /**
         * Set description
         * @param description An internal description that identifies this resource. Must be no longer than 255 characters.  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder description(String description) {
            this.description = description;
            return this;
        }
        
        /**
         * Set metadata
         * @param metadata Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters &#x60;\\\&quot;&#x60; and &#x60;\\\\&#x60;. i.e. &#39;{\\\&quot;customer_id\\\&quot; : \\\&quot;NEWYORK2015\\\&quot;}&#39; Nested objects are not supported.  See [Metadata](#section/Metadata) for more information. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder metadata(Map<String, String> metadata) {
            this.metadata = metadata;
            return this;
        }
        
        /**
         * Set mailType
         * @param mailType  (optional, default to usps_first_class)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder mailType(MailType mailType) {
            this.mailType = mailType;
            return this;
        }
        
        /**
         * Set mergeVariables
         * @param mergeVariables You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: &#x60;{{variable_name}}&#x60;, pass in &#x60;{\\\&quot;variable_name\\\&quot;: \\\&quot;Harry\\\&quot;}&#x60; to render &#x60;Harry&#x60;. &#x60;merge_variables&#x60; must be an object. Any type of value is accepted as long as the object is valid JSON; you can use &#x60;strings&#x60;, &#x60;numbers&#x60;, &#x60;booleans&#x60;, &#x60;arrays&#x60;, &#x60;objects&#x60;, or &#x60;null&#x60;. The max length of the object is 25,000 characters. If you call &#x60;JSON.stringify&#x60; on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: &#x60;!&#x60;, &#x60;\\\&quot;&#x60;, &#x60;#&#x60;, &#x60;%&#x60;, &#x60;&amp;&#x60;, &#x60;&#39;&#x60;, &#x60;(&#x60;, &#x60;)&#x60;, &#x60;*&#x60;, &#x60;+&#x60;, &#x60;,&#x60;, &#x60;/&#x60;, &#x60;;&#x60;, &#x60;&lt;&#x60;, &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;@&#x60;, &#x60;[&#x60;, &#x60;\\\\&#x60;, &#x60;]&#x60;, &#x60;^&#x60;, &#x60;&#x60; &#x60; &#x60;&#x60;, &#x60;{&#x60;, &#x60;|&#x60;, &#x60;}&#x60;, &#x60;~&#x60;. More instructions can be found in &lt;a href&#x3D;\\\&quot;https://help.lob.com/print-and-mail/designing-mail-creatives/dynamic-personalization#using-html-and-merge-variables-10\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;our guide to using html and merge variables&lt;/a&gt;. Depending on your &lt;a href&#x3D;\\\&quot;https://dashboard.lob.com/#/settings/account\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;Merge Variable strictness&lt;/a&gt; setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder mergeVariables(String mergeVariables) {
            this.mergeVariables = mergeVariables;
            return this;
        }
        
        /**
         * Set sendDate
         * @param sendDate  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder sendDate(Object sendDate) {
            this.sendDate = sendDate;
            return this;
        }
        
        /**
         * Set _file
         * @param _file  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder _file(Object _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set extraService
         * @param extraService  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder extraService(ExtraService extraService) {
            this.extraService = extraService;
            return this;
        }
        
        /**
         * Set cards
         * @param cards A single-element array containing an existing card id in a string format. See [cards](#tag/Cards) for more information. Not available for &#x60;us_legal&#x60; letter size. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder cards(List<String> cards) {
            this.cards = cards;
            return this;
        }
        
        /**
         * Set color
         * @param color  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder color(Boolean color) {
            this.color = color;
            return this;
        }
        
        /**
         * Set doubleSided
         * @param doubleSided Set this attribute to &#x60;true&#x60; for double sided printing, or &#x60;false&#x60; for for single sided printing. Defaults to &#x60;true&#x60;. (optional, default to true)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder doubleSided(Boolean doubleSided) {
            this.doubleSided = doubleSided;
            return this;
        }
        
        /**
         * Set addressPlacement
         * @param addressPlacement  (optional, default to top_first_page)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder addressPlacement(AddressPlacement addressPlacement) {
            this.addressPlacement = addressPlacement;
            return this;
        }
        
        /**
         * Set returnEnvelope
         * @param returnEnvelope  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder returnEnvelope(Object returnEnvelope) {
            this.returnEnvelope = returnEnvelope;
            return this;
        }
        
        /**
         * Set perforatedPage
         * @param perforatedPage Required if &#x60;return_envelope&#x60; is &#x60;true&#x60;. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to &#x60;1&#x60;. The blank page added by &#x60;address_placement&#x3D;insert_blank_page&#x60; will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our &lt;a href&#x3D;\\\&quot;https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;perforation guide&lt;/a&gt;. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder perforatedPage(Integer perforatedPage) {
            this.perforatedPage = perforatedPage;
            return this;
        }
        
        /**
         * Set customEnvelope
         * @param customEnvelope Accepts an envelope ID for any customized envelope with available inventory. If no inventory is available for the specified ID, the letter will not be sent, and an error will be returned. If the letter has more than 6 sheets, it will be sent in a blank flat envelope. Custom envelopes may be created and ordered from the dashboard. This feature is exclusive to certain customers. Upgrade to the appropriate &lt;a href&#x3D;\\\&quot;https://dashboard.lob.com/#/settings/editions\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;Print &amp; Mail Edition&lt;/a&gt; to gain access. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder customEnvelope(String customEnvelope) {
            this.customEnvelope = customEnvelope;
            return this;
        }
        
        /**
         * Set billingGroupId
         * @param billingGroupId An optional string with the billing group ID to tag your usage with. Is used for billing purposes. Requires special activation to use. See &lt;a href&#x3D;\\\&quot;#tag/Billing-Groups\\\&quot;&gt;Billing Group API&lt;/a&gt; for more information. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder billingGroupId(String billingGroupId) {
            this.billingGroupId = billingGroupId;
            return this;
        }
        
        /**
         * Set qrCode
         * @param qrCode  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder qrCode(QrCode qrCode) {
            this.qrCode = qrCode;
            return this;
        }
        
        /**
         * Set useType
         * @param useType  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder useType(LtrUseType useType) {
            this.useType = useType;
            return this;
        }
        
        /**
         * Set fsc
         * @param fsc This is in beta. Contact support@lob.com or your account contact to learn more. Not available for &#x60;A4&#x60; and &#x60;us_legal&#x60; letter size. (optional, default to false)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder fsc(Boolean fsc) {
            this.fsc = fsc;
            return this;
        }
        
        /**
         * Set size
         * @param size  (optional, default to us_letter)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder size(LtrSize size) {
            this.size = size;
            return this;
        }
        
        /**
         * Set idempotencyKey
         * @param idempotencyKey A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our &lt;a href&#x3D;\&quot;https://help.lob.com/print-and-mail/building-a-mail-strategy/managing-mail-settings#idempotent-requests-12\&quot; target&#x3D;\&quot;_blank\&quot;&gt;implementation guide&lt;/a&gt;.  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder idempotencyKey(String idempotencyKey) {
            this.idempotencyKey = idempotencyKey;
            return this;
        }
        
        /**
         * Set idempotencyKey2
         * @param idempotencyKey2 A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our &lt;a href&#x3D;\&quot;https://help.lob.com/print-and-mail/building-a-mail-strategy/managing-mail-settings#idempotent-requests-12\&quot; target&#x3D;\&quot;_blank\&quot;&gt;implementation guide&lt;/a&gt;.  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder idempotencyKey2(String idempotencyKey2) {
            this.idempotencyKey2 = idempotencyKey2;
            return this;
        }
        
        /**
         * Set lobVersion
         * @param lobVersion A string representing the version of the API being used. For more information on versioning, refer to our [Versioning and Changelog](https://docs.lob.com/#tag/Versioning-and-Changelog) documentation.  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder lobVersion(String lobVersion) {
            this.lobVersion = lobVersion;
            return this;
        }
        
        /**
         * Build call for create
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  * ratelimit-limit -  <br>  * ratelimit-remaining -  <br>  * ratelimit-reset -  <br>  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LetterEditable letterEditable = buildBodyParams();
            return createCall(letterEditable, idempotencyKey, idempotencyKey2, lobVersion, _callback);
        }

        private LetterEditable buildBodyParams() {
            LetterEditable letterEditable = new LetterEditable();
            return letterEditable;
        }

        /**
         * Execute create request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  * ratelimit-limit -  <br>  * ratelimit-remaining -  <br>  * ratelimit-reset -  <br>  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            LetterEditable letterEditable = buildBodyParams();
            ApiResponse<Object> localVarResp = createWithHttpInfo(letterEditable, idempotencyKey, idempotencyKey2, lobVersion);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute create request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  * ratelimit-limit -  <br>  * ratelimit-remaining -  <br>  * ratelimit-reset -  <br>  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            LetterEditable letterEditable = buildBodyParams();
            return createWithHttpInfo(letterEditable, idempotencyKey, idempotencyKey2, lobVersion);
        }

        /**
         * Execute create request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  * ratelimit-limit -  <br>  * ratelimit-remaining -  <br>  * ratelimit-reset -  <br>  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            LetterEditable letterEditable = buildBodyParams();
            return createAsync(letterEditable, idempotencyKey, idempotencyKey2, lobVersion, _callback);
        }
    }

    /**
     * Create
     * Creates a new letter given information
     * @param letterEditable  (required)
     * @return CreateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a letter object </td><td>  * ratelimit-limit -  <br>  * ratelimit-remaining -  <br>  * ratelimit-reset -  <br>  </td></tr>
        <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public CreateRequestBuilder create() throws IllegalArgumentException {
        return new CreateRequestBuilder();
    }
    private okhttp3.Call listCall(Integer limit, AddressesListBeforeAfterParameter beforeAfter, List<String> include, Map<String, String> dateCreated, Map<String, String> metadata, String campaignId, Status status, Boolean color, Boolean scheduled, Object sendDate, MailType mailType, ChecksListSortByParameter sortBy, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/letters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (beforeAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before/after", beforeAfter));
        }

        if (include != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "include", include));
        }

        if (dateCreated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_created", dateCreated));
        }

        if (metadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("metadata", metadata));
        }

        if (campaignId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("campaign_id", campaignId));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (color != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("color", color));
        }

        if (scheduled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scheduled", scheduled));
        }

        if (sendDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("send_date", sendDate));
        }

        if (mailType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mail_type", mailType));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_by", sortBy));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listValidateBeforeCall(Integer limit, AddressesListBeforeAfterParameter beforeAfter, List<String> include, Map<String, String> dateCreated, Map<String, String> metadata, String campaignId, Status status, Boolean color, Boolean scheduled, Object sendDate, MailType mailType, ChecksListSortByParameter sortBy, final ApiCallback _callback) throws ApiException {
        return listCall(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy, _callback);

    }


    private ApiResponse<LettersListResponse> listWithHttpInfo(Integer limit, AddressesListBeforeAfterParameter beforeAfter, List<String> include, Map<String, String> dateCreated, Map<String, String> metadata, String campaignId, Status status, Boolean color, Boolean scheduled, Object sendDate, MailType mailType, ChecksListSortByParameter sortBy) throws ApiException {
        okhttp3.Call localVarCall = listValidateBeforeCall(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy, null);
        Type localVarReturnType = new TypeToken<LettersListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAsync(Integer limit, AddressesListBeforeAfterParameter beforeAfter, List<String> include, Map<String, String> dateCreated, Map<String, String> metadata, String campaignId, Status status, Boolean color, Boolean scheduled, Object sendDate, MailType mailType, ChecksListSortByParameter sortBy, final ApiCallback<LettersListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listValidateBeforeCall(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy, _callback);
        Type localVarReturnType = new TypeToken<LettersListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListRequestBuilder {
        private Integer limit;
        private AddressesListBeforeAfterParameter beforeAfter;
        private List<String> include;
        private Map<String, String> dateCreated;
        private Map<String, String> metadata;
        private String campaignId;
        private Status status;
        private Boolean color;
        private Boolean scheduled;
        private Object sendDate;
        private MailType mailType;
        private ChecksListSortByParameter sortBy;

        private ListRequestBuilder() {
        }

        /**
         * Set limit
         * @param limit How many results to return. (optional, default to 10)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set beforeAfter
         * @param beforeAfter &#x60;before&#x60; and &#x60;after&#x60; are both optional but only one of them can be in the query at a time.  (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder beforeAfter(AddressesListBeforeAfterParameter beforeAfter) {
            this.beforeAfter = beforeAfter;
            return this;
        }
        
        /**
         * Set include
         * @param include Request that the response include the total count by specifying &#x60;include&#x3D;[\&quot;total_count\&quot;]&#x60;.  (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder include(List<String> include) {
            this.include = include;
            return this;
        }
        
        /**
         * Set dateCreated
         * @param dateCreated Filter by date created. Accepted formats are ISO-8601 date or datetime, e.g. &#x60;{ \&quot;gt\&quot;: \&quot;2012-01-01\&quot;, \&quot;lt\&quot;: \&quot;2012-01-31T12:34:56Z\&quot; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder dateCreated(Map<String, String> dateCreated) {
            this.dateCreated = dateCreated;
            return this;
        }
        
        /**
         * Set metadata
         * @param metadata Filter by metadata key-value pair&#x60;. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder metadata(Map<String, String> metadata) {
            this.metadata = metadata;
            return this;
        }
        
        /**
         * Set campaignId
         * @param campaignId Filters resources created by the provided campaign id, prefixed with &#x60;cmp_&#x60;. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder campaignId(String campaignId) {
            this.campaignId = campaignId;
            return this;
        }
        
        /**
         * Set status
         * @param status A string describing the render status: * &#x60;processed&#x60; - the rendering process is currently underway. * &#x60;rendered&#x60; - the rendering process has completed successfully. * &#x60;failed&#x60; - the rendering process has failed.  (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder status(Status status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set color
         * @param color Set to &#x60;true&#x60; to return only color letters. Set to &#x60;false&#x60; to return only black &amp; white letters. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder color(Boolean color) {
            this.color = color;
            return this;
        }
        
        /**
         * Set scheduled
         * @param scheduled * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;  (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder scheduled(Boolean scheduled) {
            this.scheduled = scheduled;
            return this;
        }
        
        /**
         * Set sendDate
         * @param sendDate Filter by ISO-8601 date or datetime, e.g. &#x60;{ \&quot;gt\&quot;: \&quot;2012-01-01\&quot;, \&quot;lt\&quot;: \&quot;2012-01-31T12:34:56Z\&quot; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.  (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder sendDate(Object sendDate) {
            this.sendDate = sendDate;
            return this;
        }
        
        /**
         * Set mailType
         * @param mailType A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a &lt;a href&#x3D;\&quot;https://lob.com/pricing/print-mail#compare\&quot; target&#x3D;\&quot;_blank\&quot;&gt;cheaper option&lt;/a&gt; which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.  (optional, default to usps_first_class)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder mailType(MailType mailType) {
            this.mailType = mailType;
            return this;
        }
        
        /**
         * Set sortBy
         * @param sortBy Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.  (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder sortBy(ChecksListSortByParameter sortBy) {
            this.sortBy = sortBy;
            return this;
        }
        
        /**
         * Build call for list
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A dictionary with a data property that contains an array of up to &#x60;limit&#x60; letters. Each entry in the array is a separate letter. The previous and next page of letters can be retrieved by calling the endpoint contained in the &#x60;previous_url&#x60; and &#x60;next_url&#x60; fields in the API response respectively. If no more letters are available beyond the current set of returned results, the &#x60;next_url&#x60; field will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listCall(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy, _callback);
        }


        /**
         * Execute list request
         * @return LettersListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A dictionary with a data property that contains an array of up to &#x60;limit&#x60; letters. Each entry in the array is a separate letter. The previous and next page of letters can be retrieved by calling the endpoint contained in the &#x60;previous_url&#x60; and &#x60;next_url&#x60; fields in the API response respectively. If no more letters are available beyond the current set of returned results, the &#x60;next_url&#x60; field will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public LettersListResponse execute() throws ApiException {
            ApiResponse<LettersListResponse> localVarResp = listWithHttpInfo(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute list request with HTTP info returned
         * @return ApiResponse&lt;LettersListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A dictionary with a data property that contains an array of up to &#x60;limit&#x60; letters. Each entry in the array is a separate letter. The previous and next page of letters can be retrieved by calling the endpoint contained in the &#x60;previous_url&#x60; and &#x60;next_url&#x60; fields in the API response respectively. If no more letters are available beyond the current set of returned results, the &#x60;next_url&#x60; field will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LettersListResponse> executeWithHttpInfo() throws ApiException {
            return listWithHttpInfo(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy);
        }

        /**
         * Execute list request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A dictionary with a data property that contains an array of up to &#x60;limit&#x60; letters. Each entry in the array is a separate letter. The previous and next page of letters can be retrieved by calling the endpoint contained in the &#x60;previous_url&#x60; and &#x60;next_url&#x60; fields in the API response respectively. If no more letters are available beyond the current set of returned results, the &#x60;next_url&#x60; field will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LettersListResponse> _callback) throws ApiException {
            return listAsync(limit, beforeAfter, include, dateCreated, metadata, campaignId, status, color, scheduled, sendDate, mailType, sortBy, _callback);
        }
    }

    /**
     * List
     * Returns a list of your letters. The letters are returned sorted by creation date, with the most recently created letters appearing first.
     * @return ListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A dictionary with a data property that contains an array of up to &#x60;limit&#x60; letters. Each entry in the array is a separate letter. The previous and next page of letters can be retrieved by calling the endpoint contained in the &#x60;previous_url&#x60; and &#x60;next_url&#x60; fields in the API response respectively. If no more letters are available beyond the current set of returned results, the &#x60;next_url&#x60; field will be empty. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public ListRequestBuilder list() throws IllegalArgumentException {
        return new ListRequestBuilder();
    }
    private okhttp3.Call retrieveCall(String ltrId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/letters/{ltr_id}"
            .replace("{" + "ltr_id" + "}", localVarApiClient.escapeString(ltrId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call retrieveValidateBeforeCall(String ltrId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ltrId' is set
        if (ltrId == null) {
            throw new ApiException("Missing the required parameter 'ltrId' when calling retrieve(Async)");
        }

        return retrieveCall(ltrId, _callback);

    }


    private ApiResponse<Object> retrieveWithHttpInfo(String ltrId) throws ApiException {
        okhttp3.Call localVarCall = retrieveValidateBeforeCall(ltrId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call retrieveAsync(String ltrId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = retrieveValidateBeforeCall(ltrId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class RetrieveRequestBuilder {
        private final String ltrId;

        private RetrieveRequestBuilder(String ltrId) {
            this.ltrId = ltrId;
        }

        /**
         * Build call for retrieve
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return retrieveCall(ltrId, _callback);
        }


        /**
         * Execute retrieve request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = retrieveWithHttpInfo(ltrId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute retrieve request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return retrieveWithHttpInfo(ltrId);
        }

        /**
         * Execute retrieve request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a letter object </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return retrieveAsync(ltrId, _callback);
        }
    }

    /**
     * Retrieve
     * Retrieves the details of an existing letter. You need only supply the unique letter identifier that was returned upon letter creation.
     * @param ltrId id of the letter (required)
     * @return RetrieveRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a letter object </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public RetrieveRequestBuilder retrieve(String ltrId) throws IllegalArgumentException {
        if (ltrId == null) throw new IllegalArgumentException("\"ltrId\" is required but got null");
            

        return new RetrieveRequestBuilder(ltrId);
    }
}
